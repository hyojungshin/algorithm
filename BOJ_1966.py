### 1966
### 프린터 큐

# 1. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
# 2. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.

## 입력
#. 첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.
#. 테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다. 
# 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.

caseN = int(input())

for i in range(caseN):
    # 입력 데이터 구분
    n, m = list(map(int, input().split(' ')))
    queue = list(map(int, input().split(' ')))
    # [(j, idx), (j+1, idx+1)...(j+n, idx+n)] : 원소(중요도)와 idx를 태그 형태로 묶음
    queue = [(j, idx) for idx, j in enumerate(queue)] # enumerate: list에서 idx와 원소를 같이 뽑아 줌

    cnt = 0
    while True:
        # queue[0][0] - 첫번째 원소 튜플의 첫번째 요소가 최대 중요도인지 확인
        # max(queue, key=lambda x: x[0])[0] - 튜플의 첫번째 요소 기준으로 최대 중요도 튜플 찾고 그 중 첫번째 요소 
        if queue[0][0] == max(queue, key=lambda x: x[0])[0]: # lambda x는 queue의 원소 하나, x[0]는 원소인 튜플의 첫번째 요소로 최대 중요도 튜플 찾고 그 중 첫번째 즉 최대 중요도 숫자 확인  
            cnt += 1
            # 최대 중요도가 맞다면, 찾던 m번째 인덱스인지 확인
            if queue[0][1] == m:
                print(cnt)
                break
            else:
                # 찾던 m번째 인덱스가 아니면 큐에서만 제거
                queue.pop(0)
        else:
            # 최대 중요도가 아니면 첫번째 항목을 마지막에 붙임
            queue.append(queue.pop(0)) 


# 예제
# 3  -- 테스트 케이스 수 (2줄씩 * 3개)
# 1 0 -- N, 문서의 개수 / M, 타켓 문서의 Queue 인덱스 (0번부터)
# 5 -- 중요도
# 4 2
# 1 2 3 4
# 6 0
# 1 1 9 1 1 1

# 정답
# 1
# 2
# 5
